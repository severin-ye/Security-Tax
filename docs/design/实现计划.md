Step 0｜工程初始化（一次性）

建目录与空文件（按你已定的结构）

配依赖（建议）

langchain（核心）

你选用的模型包（例如 langchain-openai 或本地模型适配）

pydantic（schema）

pyyaml（configs）

pytest（tests）

约定输出目录：每次运行生成 outputs/runs/<timestamp>_seedX/

产出物：

pyproject.toml

configs/*.yaml

outputs/ 目录约定写进 README

Step 1｜定义“结构化工具接口”（LangChain 的最小可用闭环）

你要做多智能体传播，关键在于：LLM 必须通过工具才能发消息/执行。因此第一步就是工具。

实现：

src/tools/messaging.py

send_message(sender, receiver, content)：向 receiver 的队列投递消息

src/tools/run_code.py

run_code(code)：先返回“模拟执行结果”（后面再加风险判定）

src/tools/langchain_adapters.py

把上述函数封装成 LangChain StructuredTool

产出物（验收标准）：

你能用 LangChain 直接调用 send_message 和 run_code（即使还没上 agent loop）

Step 2｜定义统一的 Prompt 构造（system + memory + incoming_message）

实现：

src/agents/memory/store.py

MemoryStore：append/prepend，返回“可拼进 prompt 的 messages”

src/llm/prompts.py

build_messages(system, memory, incoming)：输出 LangChain 需要的 message list

src/agents/prompt_templates/base_system.jinja2

src/agents/prompt_templates/scratchpad.jinja2

产出物（验收标准）：

给定 system + memory + incoming_message → 产出一致、可测试的 prompt messages

Step 3｜实现单个 AgentRuntime（LangChain AgentExecutor 驱动）

这里开始进入论文的“每个 agent 一个 runtime”。

实现：

src/agents/runtime/message_queue.py

FIFO：asyncio.Queue

src/agents/runtime/agent_runtime.py

成员变量：self.queue、self.memory

async step()：

msg = await queue.get()

prompt = system + memory + msg

调 LangChain AgentExecutor.ainvoke()

执行工具（由 AgentExecutor 触发）

把本轮对话写回 memory（append）

src/llm/factory.py

返回 LLM（OpenAI/本地）给 AgentExecutor 使用

产出物（验收标准）：

单个 agent 能消费队列消息，并调用工具（至少调用一次 send_message 或 run_code）

Step 4｜多 Agent 创建与路由（agents_by_name）

实现：

src/agents/runtime/agent_factory.py

根据 roles/*.yaml 创建不同 agent（system prompt 不同）

每次 new：必须 new queue + new memory

src/orchestrator/simulation.py

初始化 7 个 agent 放进 agents_by_name

注入初始任务到 Atlas 队列

src/tools/messaging.py

使用 agents_by_name[receiver].queue.put(...) 投递消息

产出物（验收标准）：

messages.jsonl 能看到 Atlas → others 的多次投递

队列与记忆均为 agent 私有（不共享）

Step 5｜并行调度（asyncio，多 worker）

实现：

src/orchestrator/scheduler.py

每个 agent 启动一个 worker：while not terminated: await agent.step()

src/orchestrator/lifecycle.py

终止条件最小版：

max_messages

死锁（所有队列空且超过 deadlock_timeout_s）

产出物（验收标准）：

7 个 agent 并行运行，能稳定退出，不会卡死

Step 6｜日志系统（必须早做，否则后面没法评测/画传播图）

实现：

src/common/types.py

src/common/logging.py

src/orchestrator/tracing.py

统一写：

events.jsonl

messages.jsonl

tool_calls.jsonl

outcomes.json

config_snapshot.yaml

产出物（验收标准）：

每次运行 outputs 下有完整五件套，且能复现（seed 固定）

Step 7｜run_code 风险判定 → 爆炸终止（复现实验 1 的核心终止）

实现：

src/tools/risk_rules.py

最小规则：检测危险三要素组合（先关键词/结构化字段均可）

src/tools/run_code.py

调 risk_rules，命中则上报 “EXPLOSION” 给 orchestrator

src/orchestrator/lifecycle.py

增加终止原因：爆炸

产出物（验收标准）：

一旦 agent 调 run_code 且触发危险规则 → 立刻终止并记录 outcome

Step 8｜攻击注入（第 2 条消息后）

实现：

src/attacks/prompt_bank.py：读 data/attacks/jailbreak_prompts.jsonl

src/attacks/target_selection.py：排除 Atlas/Deng，seed 可复现

src/attacks/schedule.py：全局 dequeued_count==2 时触发

src/attacks/injector.py：向目标队列 put 恶意消息

src/orchestrator/injection_points.py：把注入点挂到 orchestrator 的事件循环上

产出物（验收标准）：

logs 可验证：确实“第 2 条消息处理后”注入

messages.jsonl 可看到恶意消息进入队列并开始多跳传播

Step 9｜防御 1：指令防御（passive / active）

实现：

src/defenses/instructions.py：两档 policy 文本

src/agents/runtime/policy_hooks.py：system patch hook

configs/defense_matrix.yaml：加入 INSTR_PASSIVE / INSTR_ACTIVE

产出物（验收标准）：

同样的 seed 下，开启 defense 后爆炸率下降（不保证 0，但趋势要出来）

Step 10｜防御 2：记忆疫苗（passive / active）

实现：

src/defenses/vaccines.py

src/agents/memory/vaccines.py：读取数据并 prepend

configs/defense_matrix.yaml：加入 VAX_PASSIVE / VAX_ACTIVE

产出物（验收标准）：

疫苗必须出现在 memory 的最前面（写入日志 snapshot 可检查）

Step 11｜评测：robustness + cooperation

实现：

src/eval/robustness.py：从 outcomes 汇总爆炸率

src/eval/cooperation.py：读 data/harmless/weird_but_safe.jsonl，统计接受率

src/eval/report.py：导出 CSV

scripts/run_batch.py：defense_matrix × seeds 批量跑

产出物：

outputs/reports/table_robustness.csv

outputs/reports/table_cooperation.csv

Step 12｜传播分析与可视化

实现：

src/eval/propagation.py

从 messages.jsonl 建传播图并输出指标（多跳路径/感染链长度）

scripts/make_figures.py

输出传播图（HTML 或 PNG）

产出物：传播图 + 传播统计